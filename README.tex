\documentclass{article}
\usepackage{graphicx} % Required for inserting images
\usepackage{array}
\usepackage{booktabs}
\usepackage{listings}
\usepackage{booktabs}
\usepackage{array}
%\usepackage{fontspec} % for XeLaTeX/LuaLaTeX
% or
\usepackage{lmodern} % for pdfLaTeX
\usepackage{xcolor}
\definecolor{iris}{rgb}{0.35, 0.31, 0.81}
\definecolor{ivory}{rgb}{1.0, 1.0, 0.94}
\definecolor{jonquil}{rgb}{0.98, 0.85, 0.37}
\definecolor{Jade}{rgb}{0.0, 0.66, 0.42}
\definecolor{lavender}{rgb}{0.84, 0.79, 0.87}

\title{Biological Data Summary}
\author{Peter Shaw}
\date{August 2024}

\begin{document}
\lstset{
    language=Python,
    basicstyle=\small\ttfamily,
    numbers=left,
    numbersep=5pt,
    frame=single,
    captionpos=b,
    breaklines=true,
    breakatwhitespace=false
}

\maketitle

\section{Eye data}
\subsection{background}

\textbf{
Q? From a genetics perspective, please briefly describe what a DMR is?\\
}
\textbf{
Q? ok expand this definition to explain why you want 3D genetic data to find genes enhanced by a DMR?\\
}
{\color{iris} LLM generated

A Differentially Methylated Region (DMR) is a genomic region where DNA methylation levels differ significantly between two or more groups, such as different cell types, tissues, or disease states. DNA methylation typically acts to repress gene expression by preventing transcription factors from binding to the promoter regions of genes.

When we identify DMRs, it's often because we want to understand which genes are regulated by these epigenetic changes. However, DMRs can be located far away from the genes they regulate, and traditional 2D genomics approaches (e.g., ChIP-seq, bisulfite sequencing) may not provide enough information to connect a DMR to its target gene(s).

This is where 3D genetic data comes in!

Chromatin conformation capture techniques like Hi-C, Micro-C, or 4C allow us to study the three-dimensional organization of chromatin and identify long-range interactions between different genomic regions. These interactions can bring together distant regulatory elements (e.g., enhancers) with their target genes.

By integrating DMRs with 3D genetic data, we can:

Link DMRs to potential target genes : By identifying which genes are in close proximity to a DMR in the 3D space of chromatin, we can infer which genes might be regulated by that DMR.
Prioritize candidate regulatory elements : Hi-C and other 3D genomics data help identify topologically associating domains (TADs), which are self-interacting regions of chromatin that often harbor enhancer-promoter interactions. By finding DMRs within these TADs, we can focus on the most likely regulatory elements.
Enhance interpretation of GWAS results : Genome-wide association studies (GWAS) often identify variants associated with disease risk, but it's challenging to determine which genes are actually responsible for the observed associations. Integrating GWAS signals with DMRs and 3D genetic data can provide a more comprehensive understanding of how these variants affect gene regulation.
By leveraging 3D genetic data, we can gain insights into the complex relationships between epigenetic modifications (like DNA methylation), chromatin organization, and gene expression. This integrated approach helps us better understand the mechanisms underlying cellular behavior and disease pathogenesis.
}
\subsection{Tables}

We have two types of DRM data. One is computed using glm analysis (DSS1) and one using HOM1 neural networks. But both are essentially the same. The DSS spread sheet is likely more reliable. The main difference between the two tables is column Q. In the DSS data this is an AREA statistic, which is proportional to the length of each DRM. In the Home data, this is a confidence score. Both relate to the confidence of edges for that DRM.

Either of these tables can be used to produce a bipartite graph between DMRs and genes.
The DRM ID is in column D/E is the DMR ID. Each DMR connects to its closest gene (Column M in HOME1 and DSS1) and additional genes (which are obtained using 3D gene mapping and so further away > 2.5K) are listed in column R in DSS1 and column S in Home1. e.g. Rgs20/e5;Oprk1/e4. Importantly, note that e4 means enhancer e4. For example, when creating the bipartite network graph, DMR3 would only connect to Rgs20 $\cap$ Rgs20 and Oprk1. i.e. ignore the part after the / e4. When there is no enhancer data available, a period "." is placed in column S, and just the details in column M can be used.

We have no exact data for the enhancers in eyes yet. So the data in column 4 are taken from embryonic stem cell data.

In addition, column O contains some functional description. Potentially we could create a column for each functional description and match DMR to this column too.

\begin{table*}[h]
\centering
\sffamily
\setlength{\tabcolsep}{5pt}
\begin{tabular}
{@{}p{0.6cm}p{3.0cm}p{7.5cm}@{}}
\toprule
& \bf{Column Label} & \bf{Description} \\
\midrule
D & DMR ID & Unique identifier for each differentially methylated region (DMR) \\
M & Closest Gene & The gene closest to each DMR \\
Q & Area & Measure of the reliability of associations between DMRs and genes in DSS1 dataset \\
R & Additional Genes & Additional genes associated with each DMR, obtained through 3D gene mapping \\
S & ENCODE Promoter Interaction (BingRen Lab) & Enhancer information from ENCODE promoter interaction data \\
\bottomrule
\end{tabular}
\caption{Description of columns in the DSS1 dataset}
\label{table:dss1_columns}
\end{table*}

\section{Output Files}
The output files generated from the processing include:

\begin{itemize}
    \item \textbf{bipartite_graph_output.txt}: This file contains the edges of the bipartite graph, with the first line indicating the number of unique DMRs and genes. Each subsequent line represents a connection between a DMR and a gene, with the gene represented by its unique ID.
    \item \textbf{gene_ids.csv}: This CSV file contains a mapping of gene names to their unique IDs, allowing for easy reference and analysis of the genes associated with the DMRs.
    \item \textbf{bipartite_graph_output.txt.biclusters}: Contains the identified bicliques in the network, with each line representing the nodes (both DMRs and genes) that form a complete bipartite subgraph.
\end{itemize}

\subsection{Preliminary Results}
Initial analysis of the DSS1 dataset revealed several interesting patterns in the DMR-gene interaction network:

\begin{itemize}
    \item \textbf{Network Size}: The bipartite graph contained multiple connected components, with edges representing validated interactions between DMRs and genes.
    
    \item \textbf{Biclique Distribution}:
    \begin{itemize}
        \item Multiple interesting bicliques (≥3 DMRs, ≥3 genes) were identified
        \item The majority of bicliques were either trivial (1×1) or small
        \item Several larger bicliques suggest coordinated regulatory relationships
    \end{itemize}
    
    \item \textbf{Coverage Analysis}:
    \begin{itemize}
        \item Most edges in the original graph were captured by at least one biclique
        \item Some edges appeared in multiple bicliques, suggesting overlapping regulatory modules
        \item A small percentage of edges remained uncovered, potentially indicating noise or weaker interactions
    \end{itemize}
\end{itemize}

\begin{table}[h]
\centering
\begin{tabular}{lr}
\toprule
\textbf{Metric} & \textbf{Value} \\
\midrule
Total Bicliques & Multiple \\
Trivial Bicliques (1×1) & Majority \\
Interesting Bicliques (≥3×3) & Several \\
Edge Coverage & High \\
Multiple Coverage & Present \\
\bottomrule
\end{tabular}
\caption{Summary of initial bicliques analysis results}
\label{table:biclique_results}
\end{table}

These preliminary results suggest that the DMR-gene interaction network contains structured regulatory patterns, with some DMRs potentially working together to regulate groups of functionally related genes. Further biological validation would be needed to confirm these computational findings.

\textbf{Note}: The HOME1 dataset analysis is pending and will provide additional validation of these patterns when completed.

\section{Bicliques Analysis}
The analysis identifies bipartite cliques (bicliques) in the DMR-gene interaction network. A biclique represents a complete subgraph where every DMR is connected to every gene within that subgraph.

\subsection{Classification}
Bicliques are classified into three categories:
\begin{itemize}
    \item \textbf{Trivial}: Contains exactly 1 DMR and 1 gene
    \item \textbf{Small}: Contains either 2 DMRs or 2 genes (or both)
    \item \textbf{Interesting}: Contains 3 or more DMRs and 3 or more genes
\end{itemize}

\subsection{Analysis Output}
The bicliques analysis produces detailed statistics including:
\begin{itemize}
    \item Coverage metrics for DMRs, genes, and edges
    \item Size distribution of bicliques
    \item Detailed information about interesting bicliques, including:
    \begin{itemize}
        \item DMR IDs and their associated area statistics
        \item Gene names and descriptions
        \item Number of DMRs and genes in each biclique
    \end{itemize}
\end{itemize}

\subsection{Interpretation}
Interesting bicliques (≥3 DMRs, ≥3 genes) may represent important regulatory modules where multiple DMRs collectively influence multiple genes. These patterns could indicate:
\begin{itemize}
    \item Coordinated regulation of gene groups
    \item Functional relationships between genes
    \item Potential regulatory hotspots in the genome
\end{itemize}

\end{document}
import networkx as nx

def validate_bipartite_graph(B):
    """Validate the bipartite graph properties"""
    # Check for isolated nodes
    isolated = list(nx.isolates(B))
    if isolated:
        print(f"Warning: Found {len(isolated)} isolated nodes: {isolated[:5]}")
        
    # Check node degrees
    degrees = dict(B.degree())
    if min(degrees.values()) == 0:
        zero_degree_nodes = [n for n, d in degrees.items() if d == 0]
        print(f"Warning: Graph contains {len(zero_degree_nodes)} nodes with degree 0")
        print(f"First 5 zero-degree nodes: {zero_degree_nodes[:5]}")

    # Verify bipartite property
    if not nx.is_bipartite(B):
        print("Warning: Graph is not bipartite")

def greedy_rb_domination(graph, df, area_col=None):
    """Calculate a red-blue dominating set using a greedy approach"""
    # Initialize the dominating set
    dominating_set = set()

    # Get all gene nodes (bipartite=1)
    gene_nodes = set(node for node, data in graph.nodes(data=True) if data["bipartite"] == 1)

    # Keep track of dominated genes
    dominated_genes = set()

    # First, handle degree-1 genes that aren't already dominated
    for gene in gene_nodes:
        if graph.degree(gene) == 1 and gene not in dominated_genes:
            # Get the single neighbor (DMR) of this gene
            dmr = list(graph.neighbors(gene))[0]
            dominating_set.add(dmr)
            # Update dominated genes
            dominated_genes.update(graph.neighbors(dmr))

    # Get remaining undominated subgraph
    remaining_graph = graph.copy()
    remaining_graph.remove_nodes_from(dominating_set)
    remaining_graph.remove_nodes_from(dominated_genes)

    # Handle remaining components
    for component in nx.connected_components(remaining_graph):
        # Skip if component has no genes to dominate
        if not any(remaining_graph.nodes[n]["bipartite"] == 1 for n in component):
            continue

        # Get DMR nodes in this component
        dmr_nodes = [node for node in component if remaining_graph.nodes[node]["bipartite"] == 0]

        if dmr_nodes:  # If there are DMR nodes in this component
            # Add weight-based selection
            def get_node_weight(node):
                degree = len(set(graph.neighbors(node)))
                area = df.loc[node, area_col] if area_col else 1.0
                return degree * area

            # Modify selection strategy
            best_dmr = max(dmr_nodes,
                          key=lambda x: (len(set(remaining_graph.neighbors(x))),
                                       get_node_weight(x)))
            dominating_set.add(best_dmr)

    return dominating_set

def process_components(graph, df):
    """Process connected components of the graph to find dominating sets"""
    # Process larger components first
    components = sorted(nx.connected_components(graph), key=len, reverse=True)
    dominating_sets = []

    for component in components:
        if len(component) > 1:  # Skip isolated nodes
            subgraph = graph.subgraph(component)
            dom_set = greedy_rb_domination(subgraph, df)
            dominating_sets.extend(dom_set)

    return dominating_sets
